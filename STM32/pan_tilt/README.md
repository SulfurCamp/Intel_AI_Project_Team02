1. 구조 차이

* 인터럽트 방식

  1. `HAL_UART_Receive_IT(&huart2, &rx_ch, 1)`로 1바이트마다 ISR 진입.
  2. `HAL_UART_RxCpltCallback()`에서 바이트 누적 후 줄바꿈 시 파싱.
  3. 매 바이트마다 다시 `HAL_UART_Receive_IT()` 재무장.
  4. 데이터 이동: CPU가 DR→RAM 복사.
* DMA+IDLE 방식

  1. `HAL_UARTEx_ReceiveToIdle_DMA(&huart2, rx_dma_buf, N)`로 DMA 구동.
  2. UART가 DR→RAM을 DMA로 전송.
  3. **IDLE 이벤트**(프레임 간 침묵) 시 `HAL_UARTEx_RxEventCallback()` 1회 진입.
  4. 콜백에서 버퍼 구간(Size 바이트) 파싱 후 `HAL_UARTEx_ReceiveToIdle_DMA()` 재시작.
  5. NVIC: USART2(필수, IDLE), DMA 스트림(권장) 활성.

2. 데이터/인터럽트 흐름 비교

* 인터럽트: “바이트 수신 → ISR → 누적 → 재무장”이 바이트마다 반복.
* DMA+IDLE: “바이트 수신 → DMA가 메모리에 누적 → 프레임 끝(IDLE) → 콜백 1회”.

3. 장단점

* 인터럽트 방식
  장점:

  1. 구현 단순. 의존 컴포넌트 적음.
  2. 바이트 단위 최저 지연 처리 가능.
  3. 작은 트래픽에서 CPU 부하 매우 낮음.
     단점:
  4. 수신률이 커지면 ISR 빈도↑, 오버런/부하 리스크↑.
  5. HAL 호출 오버헤드가 바이트마다 발생.
  6. 긴 프레임 처리 시 캐시·메모리 비효율.
* DMA+IDLE 방식
  장점:

  1. 대량·연속 수신에서 CPU 부하 크게↓(프레임당 1회 수준).
  2. DR 비우기가 DMA로 즉시 이뤄져 오버런에 강함.
  3. 가변 길이 프레임을 줄바꿈/침묵으로 안정 분할.
     단점:
  4. 설정 복잡(NVIC 두 개, MSP의 `__HAL_LINKDMA`, 재시작 규율).
  5. 프레임 경계가 “침묵”으로 보장되지 않으면 콜백 타이밍 제어가 필요.
  6. 매우 짧은 프레임에선 인터럽트와 체감 차이 적음.

4. 언제 무엇을 쓰나

* 인터럽트 권장:

  1. 트래픽이 낮음(수십 B/s 수준).
  2. 바이트 단위 즉시 반응이 필요.
  3. 코드와 설정을 단순화해야 함.
* DMA+IDLE 권장:

  1. 20 ms 주기 대량 프레임, 수 kB/s 이상.
  2. 프레임 경계를 개행 또는 IDLE로 구분.
  3. CPU를 다른 작업에 쓰고 싶음.
* 참고: “IRQ도 아예 쓰지 않겠다”면 Circular DMA + NDTR 폴링으로 대체 가능. 전력·지연 손해 감수.

5. 성능 관점 요약

* ISR 빈도: 인터럽트=바이트당, DMA+IDLE=프레임당.
* CPU 부하: DMA+IDLE가 우세(특히 장프레임/고속).
* 지연: 인터럽트가 바이트 단위로 가장 낮음. DMA+IDLE는 프레임 끝까지 대기.
* 견고성: DMA가 오버런에 강함.
* 복잡도: 인터럽트 < DMA+IDLE.

6. 현재 프로젝트 결론

* 20 ms 주기 대량 수신이면 DMA+IDLE가 합리적 선택.
* 프레임이 매우 짧고 드물면 기존 인터럽트로도 충분.
